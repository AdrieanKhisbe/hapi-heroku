{
  "name": "hawk",
  "description": "HTTP Hawk Authentication Scheme",
  "version": "0.5.3",
  "author": {
    "name": "Eran Hammer",
    "email": "eran@hueniverse.com",
    "url": "http://hueniverse.com"
  },
  "contributors": [],
  "repository": {
    "type": "git",
    "url": "git://github.com/hueniverse/hawk"
  },
  "main": "index",
  "keywords": [
    "http",
    "authentication",
    "scheme",
    "hawk"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "hoek": "0.0.x",
    "boom": "0.0.x",
    "cryptiles": "0.0.x"
  },
  "devDependencies": {
    "mocha": "1.x.x",
    "chai": "1.x.x",
    "request": "2.12.x"
  },
  "scripts": {
    "test": "make test && make unit"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/hueniverse/hawk/raw/master/LICENSE"
    }
  ],
  "readme": "![hawk Logo](https://raw.github.com/hueniverse/hawk/master/images/hawk.png)\r\n\r\n<img align=\"right\" src=\"https://raw.github.com/hueniverse/hawk/master/images/logo.png\" /> **Hawk** is an HTTP authentication scheme using a message authentication code (MAC) algorithm to provide partial\r\nHTTP request cryptographic verification. For more complex use cases such as access delegation, see [Oz](/hueniverse/oz).\r\n\r\nCurrent version: **0.5.3**\r\n\r\n[![Build Status](https://secure.travis-ci.org/hueniverse/hawk.png)](http://travis-ci.org/hueniverse/hawk)\r\n\r\n# Table of Content\r\n\r\n- [**Introduction**](#introduction)\r\n  - [Time Synchronization](#time-synchronization)\r\n  - [Usage Example](#usage-example)\r\n  - [Protocol Example](#protocol-example)\r\n    - [Payload Validation](#payload-validation)\r\n<p></p>\r\n- [**Single URI Authorization**](#single-uri-authorization)\r\n  - [Usage Example](#bewit-usage-example)\r\n<p></p>\r\n- [**Security Considerations**](#security-considerations)\r\n  - [MAC Keys Transmission](#mac-keys-transmission)\r\n  - [Confidentiality of Requests](#confidentiality-of-requests)\r\n  - [Spoofing by Counterfeit Servers](#spoofing-by-counterfeit-servers)\r\n  - [Plaintext Storage of Credentials](#plaintext-storage-of-credentials)\r\n  - [Entropy of Keys](#entropy-of-keys)\r\n  - [Coverage Limitations](#coverage-limitations)\r\n  - [Future Time Manipulation](#future-time-manipulation)\r\n  - [Client Clock Poisoning](#client-clock-poisoning)\r\n  - [Bewit Limitations](#bewit-limitations)\r\n<p></p>\r\n- [**Frequently Asked Questions**](#frequently-asked-questions)\r\n<p></p>\r\n- [**Acknowledgements**](#acknowledgements)\r\n\r\n# Introduction\r\n\r\n**Hawk** is an HTTP authentication scheme providing methods for making authenticated HTTP requests with\r\npartial cryptographic verification of the request, covering the HTTP method, request URI, host, and optionally\r\nthe request payload.\r\n\r\nSimilar to the HTTP [Basic access authentication scheme](http://www.ietf.org/rfc/rfc2617.txt), the **Hawk**\r\nscheme utilizes a set of client credentials which include an identifier and key. However, in contrast with\r\nthe Basic scheme, the key is never included in authenticated requests but is used to calculate a request MAC\r\nvalue which is included instead.\r\n\r\nThe **Hawk** scheme requires the establishment of a shared symmetric key between the client and the server,\r\nwhich is beyond the scope of this module. Typically, the shared credentials are established via an initial\r\nTLS-protected phase or derived from some other shared confidential information available to both the client\r\nand the server.\r\n\r\nThe primary design goals of this mechanism are to:\r\n* simplify and improve HTTP authentication for services that are unwilling or unable to employ TLS for every request,\r\n* secure the shared credentials against leakage when sent over a secure channel to the wrong server (e.g., when the client uses some form of dynamic configuration to determine where to send an authenticated request), and\r\n* mitigate the exposure of credentials sent to a malicious server over an unauthenticated secure channel due to client failure to validate the server's identity as part of its TLS handshake.\r\n\r\nUnlike the HTTP [Digest authentication scheme](http://www.ietf.org/rfc/rfc2617.txt), **Hawk** provides optional\r\nprotection against replay attacks which does not require prior interaction with the server. Instead, the client\r\nprovides a timestamp and a nonce which the server can use to prevent replay attacks outside a narrow time window.\r\nAlso unlike Digest, this mechanism is not intended to protect the key itself (user's password in Digest) because\r\nthe client and server must both have access to the key material in the clear.\r\n\r\nIn addition, **Hawk** supports a method for granting third-parties temporary access to individual resources using\r\na query parameter called _bewit_ (leather straps used to attach a tracking device to the leg of a hawk).\r\n\r\n\r\n## Time Synchronization\r\n\r\nWhen making requests, the client includes a timestamp and nonce in order to enable the server to prevent replay\r\nattacks. The nonce is generated by the client and is a string unique across all requests with the same timestamp and\r\nkey identifier combination. Without replay protection, an attacker can use a compromised (but otherwise valid and\r\nauthenticated) request more than once, gaining long term access to a protected resource.\r\n\r\nIncluding a timestamp with the nonce removes the need to retain an infinite number of nonce values for future checks.\r\nThe timestamp enables the server to restrict the time period after which a request with an old timestamp is rejected.\r\nHowever, this requires the client's clock to be in sync with the server's clock. Unlike other protocols, **Hawk**\r\nrequires the client to ensure its clock is in sync. To accomplish that, the server provides the client with its current\r\ntime in response to a bad timestamp or as part of a challenge.\r\n\r\nIn addition, to increase the protocol scalability for clients communicating with many different servers, the server\r\nprovides the name of an NTP server which can be used as a time reference for clock sync with the server.\r\n\r\nThere is no expectation that the client will adjust its system clock to match the server. In fact, that would be a\r\npotential attack vector on the client. Instead, the client only uses the server's time to calculate an offset used only\r\nfor communications with that particular server.\r\n\r\n\r\n## Usage Example\r\n\r\nServer code:\r\n\r\n```javascript\r\nvar Http = require('http');\r\nvar Hawk = require('hawk');\r\n\r\n\r\n// Credentials lookup function\r\n\r\nvar credentialsFunc = function (id, callback) {\r\n\r\n    var credentials = {\r\n        key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',\r\n        algorithm: 'sha256',\r\n        user: 'Steve'\r\n    };\r\n\r\n    return callback(null, credentials);\r\n};\r\n\r\n// Create HTTP server\r\n\r\nvar handler = function (req, res) {\r\n\r\n    Hawk.authenticate(req, credentialsFunc, {}, function (err, credentials, attributes) {\r\n\r\n        res.writeHead(!err ? 200 : 401, { 'Content-Type': 'text/plain' });\r\n        res.end(!err ? 'Hello ' + credentials.user : 'Shoosh!');\r\n    });\r\n};\r\n\r\nHttp.createServer(handler).listen(8000, 'example.com');\r\n```\r\n\r\nClient code:\r\n\r\n```javascript\r\nvar Request = require('request');\r\nvar Hawk = require('hawk');\r\n\r\n\r\n// Client credentials\r\n\r\nvar credentials = {\r\n    id: 'dh37fgj492je',\r\n    key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',\r\n    algorithm: 'sha256'\r\n}\r\n\r\n// Send authenticated request\r\n\r\nvar options = {\r\n    uri: 'http://example.com:8000/resource/1?b=1&a=2',\r\n    method: 'GET',\r\n    headers: {\r\n        authorization: Hawk.getAuthorizationHeader(credentials, 'GET', '/resource/1?b=1&a=2', 'example.com', 8000, { ext: 'some-app-data' })\r\n    }\r\n};\r\n\r\nRequest(options, function (error, response, body) {\r\n\r\n    console.log(response.statusCode + ': ' + body);\r\n});\r\n```\r\n\r\n\r\n## Protocol Example\r\n\r\nThe client attempts to access a protected resource without authentication, sending the following HTTP request to\r\nthe resource server:\r\n\r\n```\r\nGET /resource/1?b=1&a=2 HTTP/1.1\r\nHost: example.com:8000\r\n```\r\n\r\nThe resource server returns an authentication challenge. The challenge provides the client with the server's current\r\ntime and NTP server used for clock sync, which enable the client to offset its clock when making requests.\r\n\r\n```\r\nHTTP/1.1 401 Unauthorized\r\nWWW-Authenticate: Hawk ts=\"1353832200\", ntp=\"pool.ntp.org\"\r\n```\r\n\r\nThe client has previously obtained a set of **Hawk** credentials for accessing resources on the \"http://example.com/\"\r\nserver. The **Hawk** credentials issued to the client include the following attributes:\r\n\r\n* Key identifier: dh37fgj492je\r\n* Key: werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn\r\n* Algorithm: sha256\r\n\r\nThe client generates the authentication header by calculating a timestamp (e.g. the number of seconds since January 1,\r\n1970 00:00:00 GMT), generating a nonce, and constructing the normalized request string (newline separated values):\r\n\r\n```\r\nhawk.1.header\r\n1353832234\r\nj4h3g2\r\nGET\r\n/resource?a=1&b=2\r\nexample.com\r\n8000\r\n\r\nsome-app-ext-data\r\n\r\n```\r\n\r\nThe 'hawk.1.header' normalized string header is used to prevent MAC values from being reused after a potential change in how the\r\nprotocol creates the normalized string. For example, if a future version would switch the order of nonce and timestamp, it\r\ncan create an exploit opportunity for cases where the nonce is similar in format to a timestamp. In addition, the header\r\nprevents switching MAC values between a header request and a bewit request.\r\n\r\nThe request MAC is calculated using HMAC with the specified hash algorithm \"sha256\" and the key over the normalized request string.\r\nThe result is base64-encoded to produce the request MAC:\r\n\r\n```\r\n6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=\r\n```\r\n\r\nThe client includes the **Hawk** key identifier, timestamp, nonce, application specific data, and request MAC with the request using\r\nthe HTTP \"Authorization\" request header field:\r\n\r\n```\r\nGET /resource/1?b=1&a=2 HTTP/1.1\r\nHost: example.com:8000\r\nHawk id=\"dh37fgj492je\", ts=\"1353832234\", nonce=\"j4h3g2\", ext=\"some-app-ext-data\", mac=\"6R4rV5iE+NPoym+WwjeHzjAGXUtLNIxmo1vpMofpLAE=\"\r\n```\r\n\r\nThe server validates the request by calculating the request MAC again based on the request received and verifies the validity\r\nand scope of the **Hawk** credentials. If valid, the server responds with the requested resource.\r\n\r\n\r\n### Payload Validation\r\n\r\n**Hawk** provides optional payload validation. When generating the authentication header, the client calculates a payload hash\r\nusing the specified hash algorithm. The hash is calculated over the request payload prior to any content encoding (the exact\r\nrepresentation requirements should be specified by the server for payloads other than simple single-part ascii to ensure interoperability):\r\n\r\nPayload: `Thank you for flying Hawk`\r\nHash (sha256): `CBbyqZ/H0rd6nKdg3O9FS5uiQZ5NmgcXUPLut9heuyo=`\r\n\r\nThe client constructs the normalized request string (newline separated values):\r\n\r\n```\r\nhawk.1.header\r\n1353832234\r\nj4h3g2\r\nPOST\r\n/resource?a=1&b=2\r\nexample.com\r\n8000\r\nCBbyqZ/H0rd6nKdg3O9FS5uiQZ5NmgcXUPLut9heuyo=\r\nsome-app-ext-data\r\n\r\n```\r\n\r\nThen calculates the request MAC and includes the **Hawk** key identifier, timestamp, nonce, payload hash, application specific data,\r\nand request MAC with the request using the HTTP \"Authorization\" request header field:\r\n\r\n```\r\nPOST /resource/1 HTTP/1.1\r\nHost: example.com:8000\r\nHawk id=\"dh37fgj492je\", ts=\"1353832234\", nonce=\"j4h3g2\", hash=\"CBbyqZ/H0rd6nKdg3O9FS5uiQZ5NmgcXUPLut9heuyo=\", ext=\"some-app-ext-data\", mac=\"D0pHf7mKEh55AxFZ+qyiJ/fVE8uL0YgkoJjOMcOhVQU=\"\r\n```\r\n\r\n\r\n# Single URI Authorization\r\n\r\nThere are often cases in which limited and short-term access is granted to protected resource to a third party which does not\r\nhave access to the shared credentials. For example, displaying a protected image on a web page accessed by anyone. **Hawk**\r\nprovides limited support for such URIs in the form of a _bewit_ - a URI query parameter appended to the request URI which contains\r\nthe necessary credentials to authenticate the request.\r\n\r\nBecause of the significant security risks involved in issuing such access, bewit usage is purposely limited to only GET requests\r\nand for a finite period of time. Both the client and server can issue bewit credentials, however, the server should not use the same\r\ncredentials as the client to maintain clear traceability as to who issued which credentials.\r\n\r\nIn order to simplify implementation, bewit credentials do not support single-use policy and can be replayed multiple times within\r\nthe granted access timeframe. \r\n\r\n\r\n## Bewit Usage Example\r\n\r\nServer code:\r\n\r\n```javascript\r\nvar Http = require('http');\r\nvar Hawk = require('hawk');\r\n\r\n\r\n// Credentials lookup function\r\n\r\nvar credentialsFunc = function (id, callback) {\r\n\r\n    var credentials = {\r\n        key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',\r\n        algorithm: 'sha256'\r\n    };\r\n\r\n    return callback(null, credentials);\r\n};\r\n\r\n// Create HTTP server\r\n\r\nvar handler = function (req, res) {\r\n\r\n    Hawk.uri.authenticate(req, credentialsFunc, {}, function (err, credentials, attributes) {\r\n\r\n        res.writeHead(!err ? 200 : 401, { 'Content-Type': 'text/plain' });\r\n        res.end(!err ? 'Access granted' : 'Shoosh!');\r\n    });\r\n};\r\n\r\nHttp.createServer(handler).listen(8000, 'example.com');\r\n```\r\n\r\nBewit code generation:\r\n\r\n```javascript\r\nvar Request = require('request');\r\nvar Hawk = require('hawk');\r\n\r\n\r\n// Client credentials\r\n\r\nvar credentials = {\r\n    id: 'dh37fgj492je',\r\n    key: 'werxhqb98rpaxn39848xrunpaw3489ruxnpa98w4rxn',\r\n    algorithm: 'sha256'\r\n}\r\n\r\n// Generate bewit\r\n\r\nvar duration = 60 * 5;      // 5 Minutes\r\nvar bewit = Hawk.uri.getBewit(credentials, '/resource/1?b=1&a=2', 'example.com', 8080, duration, { ext: 'some-app-data' });\r\nvar uri = 'http://example.com:8000/resource/1?b=1&a=2' + '&bewit=' + bewit;\r\n```\r\n\r\n\r\n# Security Considerations\r\n\r\nThe greatest sources of security risks are usually found not in **Hawk** but in the policies and procedures surrounding its use.\r\nImplementers are strongly encouraged to assess how this module addresses their security requirements. This section includes\r\nan incomplete list of security considerations that must be reviewed and understood before deploying **Hawk** on the server.\r\n\r\n### MAC Keys Transmission\r\n\r\n**Hawk** does not provide any mechanism for obtaining or transmitting the set of shared credentials required. Any mechanism used\r\nto obtain **Hawk** credentials must ensure that these transmissions are protected using transport-layer mechanisms such as TLS.\r\n\r\n### Confidentiality of Requests\r\n\r\nWhile **Hawk** provides a mechanism for verifying the integrity of HTTP requests, it provides no guarantee of request\r\nconfidentiality. Unless other precautions are taken, eavesdroppers will have full access to the request content. Servers should\r\ncarefully consider the types of data likely to be sent as part of such requests, and employ transport-layer security mechanisms\r\nto protect sensitive resources.\r\n\r\n### Spoofing by Counterfeit Servers\r\n\r\n**Hawk** makes no attempt to verify the authenticity of the server. A hostile party could take advantage of this by intercepting\r\nthe client's requests and returning misleading or otherwise incorrect responses. Service providers should consider such attacks\r\nwhen developing services using this protocol, and should require transport-layer security for any requests where the authenticity\r\nof the resource server or of server responses is an issue.\r\n\r\n### Plaintext Storage of Credentials\r\n\r\nThe **Hawk** key functions the same way passwords do in traditional authentication systems. In order to compute the request MAC,\r\nthe server must have access to the key in plaintext form. This is in contrast, for example, to modern operating systems, which\r\nstore only a one-way hash of user credentials.\r\n\r\nIf an attacker were to gain access to these keys - or worse, to the server's database of all such keys - he or she would be able\r\nto perform any action on behalf of any resource owner. Accordingly, it is critical that servers protect these keys from unauthorized\r\naccess.\r\n\r\n### Entropy of Keys\r\n\r\nUnless a transport-layer security protocol is used, eavesdroppers will have full access to authenticated requests and request\r\nMAC values, and will thus be able to mount offline brute-force attacks to recover the key used. Servers should be careful to\r\nassign keys which are long enough, and random enough, to resist such attacks for at least the length of time that the **Hawk**\r\ncredentials are valid.\r\n\r\nFor example, if the credentials are valid for two weeks, servers should ensure that it is not possible to mount a brute force\r\nattack that recovers the key in less than two weeks. Of course, servers are urged to err on the side of caution, and use the\r\nlongest key reasonable.\r\n\r\nIt is equally important that the pseudo-random number generator (PRNG) used to generate these keys be of sufficiently high\r\nquality. Many PRNG implementations generate number sequences that may appear to be random, but which nevertheless exhibit\r\npatterns or other weaknesses which make cryptanalysis or brute force attacks easier. Implementers should be careful to use\r\ncryptographically secure PRNGs to avoid these problems.\r\n\r\n### Coverage Limitations\r\n\r\nThe request MAC only covers the HTTP `Host` header and does not cover any other headers which can often affect how the request\r\nbody is interpreted by the server (i.e. Content-Type). If the server behavior is influenced by the presence or value of such headers,\r\nan attacker can manipulate the request header without being detected. Implementers should use the `ext` feature to pass\r\napplication-specific information via the Authorization header which is protected by the request MAC.\r\n\r\n### Future Time Manipulation\r\n\r\nThe protocol relies on a clock sync between the client and server. To accomplish this, the server informs the client of its\r\ncurrent time as well as identifies the NTP server used (the client can opt to use either one to calculate the offset used for\r\nfurther interactions with the server).\r\n\r\nIf an attacker is able to manipulate this information and cause the client to use an incorrect time, it would be able to cause\r\nthe client to generate authenticated requests using time in the future. Such requests will fail when sent by the client, and will\r\nnot likely leave a trace on the server (given the common implementation of nonce, if at all enforced). The attacker will then\r\nbe able to replay the request at the correct time without detection.\r\n\r\nThe client must only use the time information provided by the server if it is sent over a TLS connection and the server identity\r\nhas been verified.\r\n\r\n### Client Clock Poisoning\r\n\r\nWhen receiving a request with a bad timestamp, the server provides the client with its current time as well as the name of an\r\nNTP server which can be used as a time reference. The client must never use the time received from the server to adjust its own\r\nclock, and must only use it to calculate an offset for communicating with that particular server.\r\n\r\nIn addition, the client must not draw any correlation between the server's time provided via the 'ts' attribute and the current\r\ntime at the NTP server indicated via the 'ntp' variable. In other works, the client must not make any conclusion about the NTP\r\nserver indicated based on the server response.\r\n\r\n### Bewit Limitations\r\n\r\nSpecial care must be taken when issuing bewit credentials to third parties. Bewit credentials are valid until expiration and cannot\r\nbe revoked or limited without using other means. Whatever resource they grant access to will be completely exposed to anyone with\r\naccess to the bewit credentials which act as bearer credentials for that particular resource. While bewit usage is limited to GET\r\nrequests only and therefore cannot be used to perform transactions or change server state, it can still be used to expose private\r\nand sensitive information.\r\n\r\n\r\n# Frequently Asked Questions\r\n\r\n### Where is the protocol specification?\r\n\r\nIf you are looking for some prose explaining how all this works, there isn't any. **Hawk** is being developed as an open source\r\nproject instead of a standard. In other words, the [code](/hueniverse/hawk/tree/master/lib) is the specification. Not sure about\r\nsomething? Open an issue!\r\n\r\n### Is it done?\r\n\r\nNo but it's getting close. Until this module reaches version 1.0.0 it is considered experimental and is likely to change. This also\r\nmeans your feedback and contribution are very welcome. Feel free to open issues with questions and suggestions.\r\n\r\n### Does **Hawk** have anything to do with OAuth?\r\n\r\nShort answer: no.\r\n\r\n**Hawk** was originally proposed as the OAuth MAC Token specification. However, the OAuth working group in its consistent\r\nincompetence failed to produce a final, usable solution to address one of the most popular use cases of OAuth 1.0 - using it\r\nto authenticate simple client-server transactions (i.e. two-legged).\r\n\r\n**Hawk** provides a simple HTTP authentication scheme for making client-server requests. It does not address the OAuth use case\r\nof delegating access to a third party. If you are looking for an OAuth alternative, check out [Oz](/hueniverse/oz).\r\n\r\n### Where can I find **Hawk** implementations in other languages?\r\n\r\n**Hawk** is only officially implemented in JavaScript as a node.js module. However, others are actively porting it to other\r\nplatforms. There is already a [PHP](https://github.com/alexbilbie/PHP-Hawk),\r\n[.NET](https://github.com/pcibraro/hawknet), and [JAVA](https://github.com/wealdtech/hawk) libraries available. The full list\r\nis maintained [here](https://github.com/hueniverse/hawk/issues?labels=port). Please add an issue is you are working on another\r\nport. A cross-platform test-suite is in the works.\r\n\r\n### Why isn't the algorithm part of the challenge or dynamically negotiated?\r\n\r\nThe algorithm used is closely related to the key issued as different algorithms require different key sizes (and other\r\nrequirements). While some keys can be used for multiple algorithm, the protocol is designed to closely bind the key and algorithm\r\n together as part of the issued credentials.\r\n\r\n### Why is Host the only header covered by the request MAC?\r\n\r\nIt is really hard to include other headers. Headers can be changed by proxies and other intermediaries and there is no\r\nwell-established way to normalize them. The only straight-forward solution is to include the headers in some blob (say,\r\nbas64 encoded JSON) and include that with the request, an approach taken by JWT and other such formats. However, that\r\ndesign violates the HTTP header boundaries, repeats information, and introduces other security issues because firewalls\r\nwill not be aware of these \"hidden\" headers. In addition, any information repeated must be compared to the duplicated\r\ninformation in the header and therefore only moves the problem elsewhere.\r\n\r\n### Why not just use HTTP Digest?\r\n\r\nDigest requires pre-negotiation to establish a nonce. This means you can't just make a request - you must first send\r\na protocol handshake to the server. This pattern has become unacceptable for most web services, especially mobile\r\nwhere extra round-trip are costly. While Hawk includes support for sending a challenge when a request lacks\r\nauthentication, it does not require it.\r\n\r\n### Why bother with all this nonce and timestamp business?\r\n\r\n**Hawk** is an attempt to find a reasonable, practical compromise between security and usability. OAuth 1.0 got timestamp\r\nand nonces half the way right but failed when it came to scalability and consistent developer experience. **Hawk** addresses\r\nit by requiring the client to sync its clock, but provides it with tools to accomplish it.\r\n\r\nIn general, replay protection is a matter of application-specific threat model. It is less of an issue on a TLS-protected\r\nsystem where the clients are implemented using best practices and are under the control of the server. Instead of dropping\r\nreplay protection, **Hawk** offers a required time window and an optional nonce verification. Together, it provides developers\r\nwith the ability to decide how to enforce their security policy without impacting the client's implementation.\r\n\r\n### Is the NTP attribute really necessary?\r\n\r\nIt's a good investment for the future. While clients can use the server time to calculate clock skew, large scale deployment\r\nof clients talking to many servers is going to make this very expensive. Such clients will need to maintain a large data set\r\nof clock offsets, and keep updating it. Instead, the NTP information allows them to keep track of much fewer clocks, especially\r\nwhen using the default 'pool.ntp.org' service.\r\n\r\n\r\n# Acknowledgements\r\n\r\n**Hawk** is a derivative work of the [HTTP MAC Authentication Scheme](http://tools.ietf.org/html/draft-hammer-oauth-v2-mac-token-05) proposal\r\nco-authored by Ben Adida, Adam Barth, and Eran Hammer, which in turn was based on the OAuth 1.0 community specification.\r\n\r\nSpecial thanks to Ben Laurie for his always insightful feedback and advice.\r\n\r\nThe **Hawk** logo was created by [Chris Carrasco](http://chriscarrasco.com).\r\n",
  "readmeFilename": "README.md",
  "_id": "hawk@0.5.3",
  "_from": "hawk@0.5.x"
}
