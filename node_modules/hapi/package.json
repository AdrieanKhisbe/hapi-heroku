{
  "name": "hapi",
  "description": "HTTP API Server framework",
  "homepage": "http://hapijs.com",
  "version": "0.11.3",
  "author": {
    "name": "Eran Hammer",
    "email": "eran@hueniverse.com",
    "url": "http://hueniverse.com"
  },
  "contributors": [
    {
      "name": "Van Nguyen",
      "email": "the.gol.effect@gmail.com"
    },
    {
      "name": "Wyatt Preul",
      "email": "wpreul@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/walmartlabs/hapi"
  },
  "main": "index",
  "keywords": [
    "framework",
    "http",
    "authentication",
    "api",
    "router"
  ],
  "engines": {
    "node": ">=0.8.0"
  },
  "dependencies": {
    "hoek": "0.0.x",
    "boom": "0.0.x",
    "joi": "0.0.x",
    "lout": "0.0.x",
    "hapi-helmet": "0.0.x",
    "hapi-log": "0.0.x",
    "hawk": "0.5.x",
    "shot": "0.0.x",
    "oz": "0.0.x",
    "async": "0.1.x",
    "request": "2.11.x",
    "formidable": "1.0.x",
    "mime": "1.2.x",
    "catbox": "0.0.x"
  },
  "devDependencies": {
    "mocha": "1.x.x",
    "chai": "1.x.x",
    "sinon": "1.x.x",
    "handlebars": "1.0.x"
  },
  "scripts": {
    "test": "make test && make unit"
  },
  "licenses": [
    {
      "type": "BSD",
      "url": "http://github.com/walmartlabs/hapi/raw/master/LICENSE"
    }
  ],
  "readme": "<a href=\"/walmartlabs/blammo\"><img src=\"https://raw.github.com/walmartlabs/blammo/master/images/from.png\" align=\"right\" /></a>\r\n![hapi Logo](https://raw.github.com/walmartlabs/hapi/master/images/hapi.png)\r\n\r\nA rich framework for building restful API services. **hapi** is a configuration-centric framework in which\r\nauthentication requirements, input validation, data caching and pre-fetching, developer documentation,\r\nand other essential facilities are provided out-of-the-box and enabled using simple JSON configuration\r\nobjects. **hapi** enables developers to focus on writing reusable business logic instead of spending time\r\nwith everything else.\r\n\r\nCurrent version: **0.11.3**\r\n\r\n[![Build Status](https://secure.travis-ci.org/walmartlabs/hapi.png)](http://travis-ci.org/walmartlabs/hapi)\r\n\r\n\r\n# Table of Content\r\n\r\n- [**Usage**](#usage)\r\n    - [**Basic Usage**](#basic-usage)\r\n<p></p>\r\n    - [**Server Construction**](#server-construction)\r\n<p></p>\r\n    - [**Server Configuration**](#server-configuration)\r\n        - [TLS](#tls)\r\n        - [Router](#router)\r\n        - [Payload](#payload)\r\n        - [Extensions](#extensions)\r\n            - [Unknown Route](#unknown-route)\r\n        - [Format](#format)\r\n          - [Error Format](#error-format)\r\n          - [Payload Format](#payload-format)\r\n        - [Files](#files)\r\n        - [Views](#views)\r\n        - [Monitor](#monitor)\r\n        - [Authentication](#authentication)\r\n        - [Cache](#cache)\r\n        - [Debug](#debug)\r\n        - [CORS](#cors)\r\n        - [Batch](#batch)\r\n        - [State](#state)\r\n<p></p>\r\n    - [**Server Events**](#server-events)\r\n<p></p>\r\n    - [**Route Configuration**](#route-configuration)\r\n        - [Configuration options](#configuration-options)\r\n        - [Override Route Defaults](#override-route-defaults)\r\n        - [Path Processing](#path-processing)\r\n            - [Parameters](#parameters)\r\n        - [Route Handler](#route-handler)\r\n            - [Response](#response)\r\n            - [Proxy](#proxy)\r\n            - [File](#file)\r\n            - [Directory](#directory)\r\n            - [View](#view)\r\n            - [Docs](#documentation)\r\n            - [Request Logging](#request-logging)\r\n        - [Query Validation](#query-validation)\r\n        - [Payload Validation](#payload-validation)\r\n        - [Path Validation](#path-validation)\r\n        - [Response Validation](#response-validation)\r\n        - [Caching](#caching)\r\n        - [Route Prerequisites](#route-prerequisites)\r\n<p></p>\r\n    - [**Data Validation**](#data-validation)\r\n<p></p>\r\n    - [**Response Errors**](#response-errors)\r\n<p></p>\r\n    - [**State Management**](#state-management)\r\n        - [Raw Cookies](#raw-cookies)\r\n<p></p>\r\n    - [**General Events Logging**](#general-events-logging)\r\n<p></p>\r\n    - [**Request Tails**](#request-tails)\r\n<p></p>\r\n    - [**Request Injection**](#request-injection)\r\n<p></p>\r\n    - [**Server Helpers**](#server-helpers)\r\n\r\n\r\n# Usage\r\n\r\n\r\n## Basic Usage\r\n\r\nThe following is a simple \"hello world\" service with a single API endpoint:\r\n\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\n// Create a server with a host and port\r\nvar server = new Hapi.Server('localhost', 8000);\r\n\r\n// Define the route\r\nvar hello = {\r\n    handler: function (request) {\r\n    \r\n        request.reply({ greeting: 'hello world' });\r\n    }\r\n};\r\n\r\n// Add the route\r\nserver.addRoute({\r\n    method: 'GET',\r\n    path: '/hello',\r\n    config: hello\r\n});\r\n\r\n// Start the server\r\nserver.start();\r\n```\r\n\r\nNow navigate to http://localhost:8000/hello and you should receive 'hello world'.\r\n\r\n\r\n## Server Construction\r\n\r\nThe **hapi** Server object is the core of the framework and is constructed by instantiating a new Server object with the following optional parameters:\r\n- _'host'_ - optional host name. Defaults to 'localhost'.\r\n- _'port'_ - optional port. Defaults to '80' (or '443' for TLS).\r\n- _'options'_ - optional configuration as described in [Server Configuration](#server-configuration).\r\n\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\n// Create a server on localhost port 80\r\nvar server = new Hapi.Server();\r\n```\r\n\r\n\r\n## Server Configuration\r\n\r\n**hapi** provides a rich set of configuration options for each server instance:\r\n\r\n- [`tls`](#tls)\r\n- [`router`](#router)\r\n- [`payload`](#payload)\r\n- [`ext`](#extensions)\r\n- [`format`](#format)\r\n- [`files`](#files)\r\n- [`monitor`](#monitor)\r\n- [`authentication`](#authentication)\r\n- [`cache`](#cache)\r\n- [`debug`](#debug)\r\n- [`cors`](#cors)\r\n- [`batch`](#batch)\r\n- [`state`](#state)\r\n\r\n\r\n### TLS\r\n\r\n**hapi** creates an HTTP server by default. To create an HTTPS server, include the `tls` object in the server configuration.\r\nThe `tls` object is passed unchanged to the node.js HTTPS server and described in the\r\n[node.js HTTPS documentation](http://nodejs.org/api/https.html#https_https_createserver_options_requestlistener).\r\n\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\nvar options = {\r\n    tls: {\r\n        key: 'your_key',\r\n        cert: 'your_cert'\r\n    }\r\n};\r\n\r\nvar server = new Hapi.Server(options);\r\n```\r\n\r\n\r\n### Router\r\n\r\nThe `router` option controls how incoming request URIs are matched against the routing table. The router only uses the first match found. Router options:\r\n- `isTrailingSlashSensitive` - determines whether the paths '/example' and '/example/' are considered different resources. Defaults to _false_.\r\n- `isCaseSensitive` - determines whether the paths '/example' and '/EXAMPLE' are considered different resources. Defaults to _true_.\r\n- `normalizeRequestPath` - determines whether a path should have certain reserved and unreserved percent encoded characters decoded.  Also, all percent encodings will be capitalized that cannot be decoded.  Defaults to _false_.\r\n\r\n\r\n### Payload\r\n\r\nThe `payload` option controls how incoming payloads (request body) are processed. Payload options:\r\n- `maxBytes` - limits the size of incoming payloads to the specified bytes count. Allowing very large payloads may cause the server to run out of memory. Defaults to _1MB_.\r\n\r\n\r\n### Extensions\r\n\r\n**hapi** does not support middleware extensibility as is commonly found in other web frameworks. Instead, **hapi** provides extension hooks for\r\nany application-specific functionality. Each extension point accepts a single function or an array of functions to be executed at a specified stage\r\nduring request processing. The required extension function signature is _function (request, next)_ where:\r\n- _'request'_ is the **hapi** request object, and\r\n- _'next'_ is the callback function the method **must** call upon completion to return control over to the router.\r\n\r\nThe extension points are:\r\n- `onRequest` - called upon new requests before any router processing. The _'request'_ object passed to the `onRequest` functions is decorated with the _'setUrl(url)'_ and _'setMethod(verb)' methods. Calls to these methods will impact how the request is router and can be used for rewrite rules.\r\n- `onPreHandler` - called after request passes validation and body parsing, before the request handler.\r\n- `onPostHandler` - called after the request handler, before sending the response. The actual state of the response depends on the response type used (e.g. direct, stream).\r\n- `onPostRoute` - called after the response was sent.\r\n- `onUnknownRoute` - if defined, overrides the default unknown resource (404) error response. The method must send the response manually via _request.raw.res_. Cannot be an array.\r\n\r\nFor example:\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\nvar options = {\r\n    ext: {\r\n        onRequest: onRequest\r\n    }\r\n};\r\n\r\n// Create server\r\nvar http = new Hapi.Server('localhost', 8000, options);\r\n\r\n// Set routes\r\nhttp.addRoute({ method: 'GET', path: '/test', handler: get });\r\n\r\n// Start server\r\nhttp.start();\r\n\r\n// Resource handler\r\nfunction get(request) {\r\n\r\n    request.reply({ status: 'ok' });\r\n}\r\n\r\n// Path rewrite\r\nfunction onRequest(request, next) {\r\n\r\n    // Change all requests to '/test'\r\n    request.setUrl('/test');\r\n    next();\r\n}\r\n```\r\n\r\n\r\n#### Unknown Route\r\n\r\n**hapi** provides a default handler for unknown routes (HTTP 404). If the application needs to override the default handler, it can use the\r\n`ext.onUnknownRoute` server option. The extension function signature is _function (request)_ where:\r\n- _'request'_ is the **hapi** request object.\r\n\r\nWhen the extension handler is called, the _'request'_ object is decorated as described in [Route Handler](#route-handler) with the following additional method:\r\n- _'reply.close()'_ - returns control over to the server after the application has taken care of responding to the request via the _request.raw.res_ object directly.\r\n\r\nThe method **must** return control over to the route using the _reply_ interface described in [Route Handler](#route-handler) or the _'reply.close()'_ method but not both.\r\n\r\nFor example, using the _'reply.close()'_ method:\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\nvar options = {\r\n    ext: {\r\n        onUnknownRoute: onUnknownRoute\r\n    }\r\n};\r\n\r\n// Create server\r\nvar http = new Hapi.Server('localhost', 8000, options);\r\n\r\n// Start server\r\nhttp.start();\r\n\r\n// 404 handler\r\nfunction onUnknownRoute(request) {\r\n\r\n    request.raw.res.writeHead(404);\r\n    request.raw.res.end();\r\n    request.reply.close();\r\n}\r\n```\r\n\r\nOr using the _'reply(result)'_ method:\r\n```javascript\r\nfunction onUnknownRoute(request) {\r\n\r\n    request.reply({ roads: 'ocean' });\r\n}\r\n```\r\n\r\n\r\n### Format\r\n\r\nThe `format` option provides an extension point for use of custom methods to format error responses or payloads before they are sent back to the client.\r\n\r\n\r\n#### Error Format\r\n\r\nIf a different error format than the default JSON response is required, the server `format.error` option can be assigned a function to generate a\r\ndifferent error response. The function signature is _'formatted = function (result)'_ where:\r\n- _'result'_ - is the **hapi** error object returned by the route handler, and\r\n- _'formatted'_ - is the formatted response object which contains the following keys:\r\n    - _`code`_ - the HTTP status code.\r\n    - _`payload`_ - the response payload.\r\n    - _`type`_ - the response payload content-type.\r\n    - _`headers`_ - any additional response HTTP headers (object).\r\n\r\nNote that the format function must be synchronous.\r\n\r\nFor example:\r\n```javascript\r\nvar options = {\r\n    format: {\r\n        error: function (result) {\r\n        \r\n            return { code: 500, payload: 'Oops: ' + result.message, type: 'text/html' };\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n\r\n#### Payload Format\r\n\r\nIn cases where every non-error payload has to be processed before being sent out (e.g. when returning a database object and need to hide certain fields or\r\nrename '_id' to 'id'), the `format.payload' option can be set to a function that is called on every result, immediately after 'request.reply' is called. The\r\nfunction's signature is _'formatted = function (result)'_ where:\r\n- _'result'_ - is the raw result object returned by the route handler, and\r\n- _'formatted'_ - is the formatted response to replace 'result'.\r\n\r\nNote that the format function must be synchronous, and it is only invoked for response types other than Stream.\r\n\r\nFor example:\r\n```javascript\r\nvar options = {\r\n    format: {\r\n        payload: function (result) {\r\n        \r\n            return 'something else instead';\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n\r\n### Views\r\n\r\nTo enable Views support, Hapi must be given an options object with a non-null `views` key. The views object\r\n supports the following options:\r\n\r\n- `path` - (Required) the root file path where the request.reply.view function will resolve template names.\r\n- `engine` - the configuration for what template rendering engine will be used (default: handlebars).\r\n    - `module` - the npm module to require and use to compile templates (**this is experimental and may not not work with all modules**).\r\n    - `extension` - the file extension used by template files.\r\n- `partials` - this key enables partials support if non-null.\r\n    - `path` - the root file path where partials are located (if different from views.path).\r\n- `layout` - if set to true, layout support is enabled (default: false).\r\n- `layoutKeyword` - the key used by the template engine to denote where primary template content should go.\r\n- `encoding` - the text encoding used by the templates.\r\n- `cache` - if set to false, templates will not be cached (thus will be read from file on every use).\r\n- `allowAbsolutePaths` - the flag to set if absolute template paths passed to .view() should be allowed.\r\n- `allowInsecureAccess` - the flag to set if `../` should be allowed in the template paths passed to `.view()`.\r\n- `compileOptions` - the options object passed to the engine's compile function (compile(string, options)).\r\n\r\n\r\n### Files\r\n\r\n**hapi** provides built-in support for serving static files and directories as described in [File](#file) and [Directory](#directory).\r\nWhen these handlers are provided with relative paths, the `files.relativeTo` server option determines how these paths are resolved\r\nand defaults to _'routes'_:\r\n- _'routes'_ - relative paths are resolved based on the location of the files in which the server's _'addRoute()'_ or _'addRoutes()'_ methods are called. This means the location of the source code determines the location of the static resources when using relative paths.\r\n- _'process'_ - relative paths are resolved using the active process path (_'process.cwd()'_).\r\n\r\n\r\n### Monitor\r\n\r\n**hapi** comes with a built-in process monitor for three types of events:\r\n- System and process performance (ops) - CPU, memory, disk, and other metrics.\r\n- Requests logging (request) - framework and application generated logs generated during the lifecycle of each incoming request.\r\n- General events (log) - logging information not bound to a specific request such as system errors, background processing, configuration errors, etc. Described in [General Events Logging](#general-events-logging).\r\n\r\nThe monitor is _off_ by default and can be turned on using the `monitor` server option. To use the default settings, simply set the value to _true_.\r\nApplications with multiple server instances, each with its own monitor should only include one _log_ subscription per destination as general events (log)\r\nare a process-wide facility and will result in duplicated log events. To override some or all of the defaults, set `monitor` to an object with the following\r\noptional settings:\r\n- `broadcastInterval` - the interval in milliseconds to send collected events to subscribers. _0_ means send immediately. Defaults to _0_.\r\n- `opsInterval` - the interval in milliseconds to sample system and process performance metrics. Minimum is _100ms_. Defaults to _15 seconds_.\r\n- `extendedRequests` - determines if the full request log is sent or only the event summary. Defaults to _false_.\r\n- `requestsEvent` - the event type used to capture completed requests. Defaults to 'tail'. Options are:\r\n    - 'response' - the response was sent but request tails may still be pending.\r\n    - 'tail' - the response was sent and all request tails completed.\r\n- `subscribers` - an object where each key is a destination and each value an array subscriptions. Subscriptions available are _ops_, _request_, and _log_. The destination can be a URI or _console_. Defaults to a console subscription to all three.\r\n\r\nFor example:\r\n```javascript\r\nvar options = {\r\n    monitor: {\r\n        subscribers: {\r\n            console: ['ops', 'request', 'log'],\r\n            'http://localhost/logs': ['log']\r\n        }\r\n    }\r\n};\r\n```\r\n\r\n\r\n### Authentication\r\n\r\nThe authentication interface is disabled by default and is still experimental.\r\n\r\n\r\n### Cache\r\n\r\n**hapi** provides a built-in caching facility for storing and reusing request responses and helpers utilities. The provided implementations include Redis and MongoDB support\r\n(each must be manually installed and configured). The cache functionality is _off_ by default. To enable caching, the `cache` option must be set to\r\nan object with the following options:\r\n- `engine` - the cache server implementation. Options are _redis_, _mongodb_, and _memory_.\r\n- `host` - the cache server hostname.\r\n- `port` - the cache server port.\r\n- `partition` - the partition name used to isolate the cached results across different servers. Defaults to 'hapi-cache'.\r\n- `username`, `password`, `poolSize` - MongoDB-specific options.\r\n\r\nFor convenience, pre-configured options are provided for Redis, MongoDB, and an experimental memory store. To use them, simply set the server's `cache` option to:\r\n- _'redis'_ - Connects to _127.0.0.1:6379_ using partition name 'hapi-cache'.\r\n- _'mongodb'_ - Connects to _127.0.0.1:27017_ using partition name 'hapi-cache', no authentication, and pool size 5.\r\n- _'memory'_ - This is an experimental engine and should be avoided in production environments.  The memory engine will run within the node process and supports the following option:\r\n    - `maxByteSize` - Sets an upper limit on the number of bytes that can be consumed by the total of everything cached in the memory engine.  Once this limit is reached no more items will be added to the cache.\r\n\r\nFor example:\r\n```javascript\r\nvar options = {\r\n    cache: 'redis'\r\n};\r\n```\r\n\r\nEnabling the server cache only creates the cache interface but does not enable caching for any individual routes or helpers, which must be enabled\r\nand configured in the route or helper configuration.\r\n\r\n\r\n### Debug\r\n\r\nTo assist in debugging server events related to specific incoming requests, **hapi** includes an optional debug console which is turned _off_ by default.\r\nThe debug console is a simple web page in which developers can subscribe to a debug id, and then include that debug id as an extra query parameter in each\r\nrequest. The server will use WebSocket to stream the subscribed request logs to the web page in real-time. In application using multiple server instances,\r\nonly one can enable the debug interface using the default port. To enable the debug console set the `debug` option to _true_ or to an object with custom\r\nconfiguration:\r\n- `websocketPort` - the port used by the WebSocket connection. Defaults to _3000_.\r\n- `debugEndpoint` - the debug console request path added to the server routes. Defaults to _'/debug/console'_.\r\n- `queryKey` - the name or the request query parameter used to mark requests being debugged. Defaults to _debug_.\r\n\r\n\r\n### CORS\r\n\r\nThe [Cross-Origin Resource Sharing](http://www.w3.org/TR/cors/) protocol allows browsers to make cross-origin API calls. This is required\r\nby web application running inside a browser which are loaded from a different domain than the API server. **hapi** provides a general purpose\r\nCORS implementation that sets very liberal restrictions on cross-origin access by default (on by default). CORS options:\r\n- `origin` - overrides the array of allowed origin servers ('Access-Control-Allow-Origin'). Defaults to any origin _'*'_.\r\n- `maxAge` - number of seconds the browser should cache the CORS response ('Access-Control-Max-Age'). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to _one day_.\r\n- `headers` - overrides the array of allowed headers ('Access-Control-Allow-Headers'). Defaults to _'Authorization, Content-Type, If-None-Match'_.\r\n- `additionalHeaders` - an array of additional headers to `headers`. Use this to keep the default headers in place.\r\n- `methods` - overrides the array of allowed methods ('Access-Control-Allow-Methods'). Defaults to _'GET, HEAD, POST, PUT, DELETE, OPTIONS'_.\r\n- `additionalMethods` - an array of additional methods to `methods`. Use this to keep the default methods in place.\r\n- `credentials` - if true, allows user credentials to be sent ('Access-Control-Allow-Credentials'). Defaults to false.\r\n\r\n**hapi** will automatically add an _OPTIONS_ handler for every route unless disabled. To disable CORS for the entire server, set the `cors` server option to _false_. To disable CORS support for a single route, set the route _config.cors_ option to _false_.\r\n\r\n\r\n### Batch\r\n\r\nThe batch endpoint makes it easy to combine requests into a single one.  It also supports pipelining so you are able to take the result of one of the endpoints in the batch request and use it in a subsequent endpoint.  The batch endpoint only responds to POST requests.\r\nBy default the batch endpoint is turned _off_.  To enable the batch endpoint set the `batch` option to _true_ or to an object with the following custom configuration:\r\n- `batchEndpoint` - the path where batch requests will be served from.  Default is '/batch'.\r\n\r\nAs an example to help explain the use of the endpoint, assume that the server has a route at '/currentuser' and '/users/{id}/profile/'.  You can make a POST request to the batch endpoint with the following body:\r\n`{ \"requests\": [ {\"method\": \"get\", \"path\": \"/currentuser\"}, {\"method\": \"get\", \"path\": \"/users/$0.id/profile\"} ] }` and it will return an array with the current user and their profile.\r\n\r\nThe response body to the batch endpoint is an ordered array of the response to each request.  Therefore, if you make a request to the batch endpoint that looks like `{ \"requests\": [ {\"method\": \"get\", \"path\": \"/users/1\"}, {\"method\": \"get\", \"path\": \"/users/2\"} ] }` the response might look like:\r\n`[{\"userId\": \"1\", \"username\": \"bob\"}, {\"userId\": \"2\", \"username\": \"billy\" }]` where the first item in the response array is the result of the request from the first item in the request array.\r\n\r\nIf an error occurs as a result of one the requests to an endpoint it will be included in the response in the same location in the array as the request causing the issue.  The error object will include an error property that you can interrogate.  At this time the response is a 200 even when a request in the batch returns a different code.\r\n\r\n*** At this time batch only supports requests to routes that use the GET method.\r\n\r\n\r\n### State\r\n\r\nHTTP state management (cookies) allows the server to store session information on the client which is sent back to the server with every\r\nrequest (as defined in [RFC 6265](https://tools.ietf.org/html/rfc6265)). **hapi** will automatically parse incoming cookies based on the\r\nserver's `state.cookies` configuration, where:\r\n- `parse` - determines is incoming 'Cookie' headers are parsed and stored in the 'request.cookies' object. Defaults to true.\r\n- _'failAction'_ - allowed values are: _'error'_ (return 500), _'log'_ (report error but continue), or _'ignore'_ (continue) when a request cookie fails parsing. Defaults to _'error'_.\r\n\r\n\r\n## Server Events\r\n\r\nThe server object emits the following events:\r\n- _'response'_ - emitted after a response is sent back. Includes the request object as value.\r\n- _'tail'_ - emitted when a request finished processing, including any registered tails as described in [Request Tails](#request-tails).\r\n\r\n\r\n## Route Configuration\r\n\r\n**hapi** was designed to move as much logic as possible from the route handler to the route configuration. The goal is to provide a simple\r\nmechanism for defining routes without having to write code. This approach also enables producing dynamic route documentation without having\r\nto write additional text as the configuration itself serves as a living documentation.\r\n\r\n\r\n### Configuration options \r\n\r\n- `path` - the absolute path or regular expression to match against incoming requests. Path comparison is configured using the server [`router`](#router) option. String paths can include named identifiers enclosed in _'{}'_ as described in [Path Parameters](#path-processing).\r\n- `method` - the HTTP method. Typically one of _'GET, POST, PUT, DELETE, OPTIONS'_. Any HTTP method is allowed, except for _'HEAD'_. **hapi** does not provide a way to add a route to all methods.\r\n- `handler` - the business logic function called after authentication and validation to generate the response. The function signature is _function (request)_ where _'request'_ is the **hapi** request object. See [Route Handler](#route-handler) for more information.  Optionally, this can be an object with a _'proxy'_, _'file'_, or _'directory'_ property:\r\n    - `proxy` - generates a reverse proxy handler as described in (Proxy)[#proxy].\r\n    - `file` - generates a static file endpoint as described in (File)[#file].\r\n    - `directory` - generates a directory mapper for service static content as described in (Directory)[#directory].\r\n- `config` - route configuration grouped into a sub-object to allow splitting the routing table from the implementation details of each route. Options include:\r\n    - `description` - route description.\r\n    - `notes` - route notes (string or array of strings).\r\n    - `tags` - route tags (array of strings).\r\n    - `handler` - an alternative location for the route handler function. Same as the `handler` option in the parent level. Can only include one handler per route.\r\n    - `validate`\r\n        - `query` - validation rules for incoming requests' query component (the key-value part of the URI between _?_ and _#_). Defaults to any query parameters being allowed. See [Query Validation](#query-validation) for more information.\r\n        - `schema` - validation rules for incoming requests' payload (request body). Defaults to no validation (any payload allowed). Set to _'false'_ to forbid payloads. See [Payload Validation](#payload-validation) for more information.\r\n        - `path` - validation rules for incoming requests' path parameters. Defaults to no validation (any path parameter allowed). Set to _'false'_ to forbid any path parameter. See [Path Validation](#path-validation) for more information.\r\n    - `response` - validation rules for outgoing responses' payload (response body). Defaults to no validation (any payload allowed). Set to an empty object _'{}'_ to forbid payloads. See [Response Validation](#response-validation) for more information.\r\n    - `payload` - determines how the request payload is processed. Defaults to _'parse'_ if `schema` is present or `method` is _'POST'_ or _'PUT'_, otherwise _'stream'_. Payload processing is configured using the server [`payload`](#payload) option. Options are:\r\n        - _'stream'_ - the incoming request stream is left untouched, leaving it up to the handler to process the request via _'request.raw.req'_. Note that the request readable stream is put in a paused state and must be resumed before it will emit data events.\r\n        - _'raw'_ - the payload is read and stored in _'request.rawBody'_ but not parsed.\r\n        - _'parse'_ - the payload is read and stored in _'request.rawBody'_ and then parsed (JSON or form-encoded) and stored in _'request.payload'_.\r\n    - `cache` - if the server `cache` option is enabled and the route method is 'GET', the route can be configured to use the cache as described in [Caching](#caching).\r\n    - `pre` - an array with pre-handler methods as described in [Route Prerequisites](#route-prerequisites). \r\n    - `auth` - authentication configuration\r\n        - `mode` - the authentication mode. Defaults to _'required'_ is the `authentication` server option is set, otherwise _'none'_. Available options include:\r\n            - _'none'_ - authentication not allowed.\r\n            - _'required'_ - authentication is required.\r\n            - _'optional'_ - authentication is optional (validated if present).\r\n        - `tos` - minimum terms-of-service version required. This is compared to the terms-of-service version accepted by the user. Defaults to _none_.\r\n        - `scope` - required application scope. Defaults to _none_.\r\n        - `entity` - the required authenticated entity type. Not supported with every authorization scheme. Available options include:\r\n            - _'any'_ - the authentication can be on behalf of a user or application.\r\n            - _'user'_ - the authentication must be on behalf of a user.\r\n            - _'app'_ - the authentication must be on behalf of an application.\r\n\r\nThe `config` option was defined for easily spliting the routing table definition from the individual route information. For example:\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\nvar server = new Hapi.Server();\r\n\r\n// Option 1 - add handler directly in route definition\r\n\r\nvar handler1 = function (request) {\r\n\r\n    request.reply('ok');\r\n}\r\n\r\nserver.addRoute({ method: 'GET', path: '/option1', handler: handler1 });\r\n\r\n// Option 2 - add handler in separate config object\r\n\r\nvar config2 = {\r\n    payload: 'raw',\r\n    // ... additional config options ...\r\n    handler: function (request) {\r\n\r\n        request.reply('ok');\r\n    }\r\n};\r\n\r\nserver.addRoute({ method: 'GET', path: '/option2', config: config2});\r\n```\r\n\r\n\r\n### Override Route Defaults\r\n\r\nEach configuration option comes with a built-in default. To change these defaults, use the `setRoutesDefaults()` server method.\r\n```javascript\r\nserver.setRoutesDefaults({\r\n    cors: false\r\n});\r\n```\r\n\r\n\r\n### Path Processing\r\n\r\nThe **hapi** router iterates through the routing table on each incoming request and executes the first (and only the first) matching route handler.\r\nRoute matching is done on the request path only (excluding the query and other components). The route `path` option support three types of paths:\r\n- Static - the route path is a static string which begin with _'/'_ and will only match incoming requests containing the exact string match (as defined by the server `router` option).\r\n- Parameterized - same as _static_ with the additional support of named parameters (enclosed in _'{}'_).\r\n\r\n\r\n#### Parameters\r\n\r\nParameterized paths are processed by matching the named parameters to the content of the incoming request path at that level. For example, the route:\r\n'/book/{id}/cover' will match: '/book/123/cover' and 'request.params.id' will be set to '123'. Each path level (everything between the opening _'/'_ and\r\n the closing _'/'_ unless it is the end of the path) can only include one named parameter. The _'?'_ suffix following the parameter name indicates\r\nan optional parameter (only allowed if the parameter is at the ends of the path). For example: the route: '/book/{id?}' will match: '/book/' (and may\r\nmatch '/book' based on the server `router` option).\r\n\r\n```javascript\r\nserver.addRoute({\r\n    path: '/{album}/{song?}',\r\n    method: 'GET',\r\n    handler: getAlbum\r\n});\r\n\r\nfunction getAlbum(request) {\r\n\r\n    request.reply('You asked for ' +\r\n                  (request.params.song ? request.params.song + ' from ' : '') +\r\n                  request.params.album);\r\n}\r\n```\r\n\r\nIn addition to the optional _'?'_ suffix, a param can also specify an expected number of parts in the path.  To do this use the _'*'_ suffix followed by a number greater than 1.  If the number of expected parts can be anything, then use the _'*'_ without a number.\r\n\r\n```javascript\r\nserver.addRoute({\r\n    path: '/person/{names*2}',\r\n    method: 'GET',\r\n    handler: getPerson\r\n});\r\n\r\nfunction getPerson(request) {\r\n\r\n    var nameParts = request.params.names.split('/');\r\n    request.reply(new Person(namesParts[0], nameParts[1]));\r\n}\r\n```\r\n\r\nIn the example code above if a request for `/person/john/smith` comes in then `request.params.names` is set to 'john/smith'.  In this example a person will be returned for the john smith.\r\n\r\nBelow is a similar example without a requirement on the number of name parts that can be passed.\r\n\r\n```javascript\r\nserver.addRoute({\r\n    path: '/people/{names*}',\r\n    method: 'GET',\r\n    handler: getPerson\r\n});\r\n\r\nfunction getPeople(request) {\r\n\r\n    var nameParts = request.params.names.split('/');\r\n    request.reply(loadPeople(namesParts));\r\n}\r\n```\r\n\r\nIn the example people are loaded by passing in a names array.  If a request comes in for `people/john/bob/jenny` then `request.params.names` is set to 'john/bob/jenny'.  Please note that the route will be matched for a request of `/people/` as names can be 0 or more parts.  As a result of this behavior, {names*} must appear as the last parameter in the route path.  In other words, a param with 0 or more path parts must appear at the end of the end of the route path.\r\n\r\n\r\n### Route Handler\r\n\r\nWhen the provided route handler method is called, it receives a _request_ object with the following properties:\r\n- _'url'_ - the parsed request URI.\r\n- _'path'_ - the request URI's path component.\r\n- _'method'_ - the request method as a _lowercase_ string. (Examples: `'get'`, `'post'`).\r\n- _'query'_ - an object containing the query parameters.\r\n- _'params'_ - an object containing the path named parameters as described in [Path Parameters](#parameters).\r\n- _'rawBody'_ - the raw request payload (except for requests with `config.payload` set to _'stream'_).\r\n- _'payload'_ - an object containing the parsed request payload (for requests with `config.payload` set to _'parse'_).\r\n- _'state'_ - an object containing parsed HTTP state information (cookies).\r\n- _'session'_ - available for authenticated requests and includes:\r\n    - _'id'_ - session identifier.\r\n    - _'used'_ - user id (optional).\r\n    - _'app'_ - application id (optional).\r\n    - _'scope'_ - approved application scopes (optional).\r\n    - _'ext.tos'_ - terms-of-service version (optional).\r\n- _'server'_ - a reference to the server object.\r\n- _'pre'_ - any requisites as described in [Prequisites](#prequisites).\r\n- _'addTail([name])'_ - adds a request tail as described in [Request Tails](#request-tails).\r\n- _'raw'_ - an object containing the Node HTTP server 'req' and 'req' objects. **Direct interaction with these raw objects is not recommended.**\r\n\r\n\r\n#### Response\r\n\r\n**hapi** provides native support for the following response types:\r\n- Empty - an empty response body (content-lenght of zero).\r\n- Text - plain text. Defaults to 'text/html' content-type.\r\n- Obj - Javascript object, converted to string. Defaults to 'application/json' content-type.\r\n- Stream - a stream object, directly piped into the HTTP response.\r\n- File - transmits a static file. Defaults to the matching mime type based on filename extension.\r\n- Direct - special response type for writing directly to the response object. Used for chunked responses.\r\n- Error - error objects generated using the 'Hapi.error' module or 'new Error()' described in [Response Errors](#response-errors).\r\n\r\nThe request object includes a _'reply'_ property which includes the following methods:\r\n- _'payload(result)'_ - sets the provided _'result'_ as the response payload. _'result'_ cannot be a Stream. The method will automatically identify the result type and cast it into one of the supported response types (Empty, Text, Obj, or Error). _'result'_ can all be an instance of any other response type provided by the 'Hapi.response' module (e.g. File, Direct).\r\n- _'stream(stream)'_ - pipes the content of the stream into the response.\r\n- _'redirect(uri)'_ - sets a redirection response. Defaults to 302.\r\n- _'send()'_ - finalizes the response and return control back to the router. Must be called after _'payload()'_ or _'stream()'_ to send the response.\r\n\r\nFor convenience, the 'response' object is also decorated with a shortcut function _'reply([result])'_ which is identical to calling _'reply.payload([result]).send()'_ or _'reply.stream(stream).send()'_.\r\n\r\nThe 'payload()', 'stream()', and 'redirect()' methods return a **hapi** Response object created based on the result item provided.\r\nDepending on the response type, additional chainable methods are available:\r\n- _'created(location)`_ - a URI value which sets the HTTP response code to 201 (Created) and adds the HTTP _Location_ header with the provided value (normalized to absolute URI). Not available with 'redirect()'.\r\n- _'bytes(length)'_ - a pre-calculated Content-Length header value. Only available when using _'pipe(stream)'_.\r\n- _'type(mimeType)'_ - a pre-determined Content-Type header value. Should only be used to override the built-in defaults.\r\n- _'ttl(msec)'_ - a milliseconds value which overrides the default route cache expiration rule for this individual response.\r\n- _'state(name, value, options)'_ - sets an HTTP state (cookie) as described in [Raw Cookies](#raw-cookies)\r\n- _'unstate(name)'_ - instructs the client to remove the HTTP state.\r\n\r\nThe following methods are only available when using 'redirect()':\r\n- _'message(text, type)'_ - a payload message and optional content type (defaults to 'text/html').\r\n- _'uri(dest)'_ - the destination URI.\r\n- _'temporary()_' - sets the status code to 302 or 307 (based on the rewritable settings). Defaults to 'true'.\r\n- _'permanent()_' - sets the status code to 301 or 308 (based on the rewritable settings). Defaults to 'false'.\r\n- _'rewritable(isRewritable)_' - sets the status code to 301/302 (based on the temporary settings) for rewritable (change POST to GET) or 307/308 for non-rewritable. Defaults to 'true'.\r\n\r\nThe handler must call _'reply()'_, _'reply.send()'_, or _'reply.payload/stream()...send()'_ (and only one, once) to return control over to the router. The reply methods are only available\r\nwithin the route handler and are disabled as soon as control is returned.\r\n\r\n\r\n#### Proxy\r\n\r\nIt is possible with hapi to setup a reverse proxy for routes.  This is especially useful if you plan to stand-up hapi in front of an existing API or you need to augment the functionality of an existing API.  Additionally, this feature is powerful in that it can be combined with caching to cache the responses from external APIs.  The proxy route configuration has the following options:\r\n- `passThrough` - determines if the headers sent from the clients user-agent will be forwarded on to the external service being proxied to (default: false)\r\n- `xforward` - determines if the x-forward headers will be set when making a request to the proxied endpoint (default: false)\r\n- `host` - The host to proxy requests to.  The same path on the client request will be used as the path to the host.\r\n- `port` - The port to use when making a request to the host.\r\n- `protocol` - The protocol to use when making a request to the proxied host (http or https)\r\n- `mapUri` - A function that receives the clients request and a passes the URI to a callback to make the proxied request to.  If host is set mapUri cannot be used, set either host or mapUri.\r\n- `postResponse` - A function that will be executed before sending the response to the client for requests that can be cached.  Use this for any custom error handling of responses from the proxied endpoint.\r\n- `httpClient` - A function that should make the request to the remote server and use execute the callback with a response.  By default this uses _'request'_ as the module.  The signature is (options, callback) where options will contain a url and method.\r\n\r\nFor example, to proxy a request to the homepage to google:\r\n```javascript\r\n// Create Hapi servers\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\n// Proxy request to / to google.com\r\nhttp.addRoute({ method: 'GET', path: '/', handler: { proxy: { protocol: 'http', host: 'google.com', port: 80 } } });\r\n\r\nhttp.start();\r\n```\r\n\r\n\r\n#### File\r\n\r\nFile handlers provide a simple way to serve a static file for a given route. This is done by specifying an object with the `file`\r\noption as the route handler. The value of the `file` option is the absolute or relative path to the static resource. Relative paths\r\nare resolved based on the server's `files` option as described in (Files)[#files]. The route path cannot contain parameters when\r\nconfigured with a static file path. For example:\r\n\r\n```javascript\r\n// Create Hapi server\r\nvar http = new Hapi.Server('0.0.0.0', 8080, { files: { relativeTo: 'process' } });\r\n\r\n// Serve index.html file up a directory in the public folder\r\nhttp.addRoute({ method: 'GET', path: '/', handler: { file: './public/index.html' } });\r\n\r\nhttp.start();\r\n```\r\n\r\nThe file handler also supports dynamic determination of the file being served based on the request, using a function as the value\r\nof the `file` option with the signature _'function (request) { return './path'; }'_.  The function is passed the request object and\r\nmust return a string with the relative or absolute path to the static resource. For example:\r\n\r\n```javascript\r\n// Create Hapi server\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\n// File mapping function\r\nvar filePath = function (request) {\r\n\r\n    if (isMobileDevice(request)) {\r\n        return './mobile/' + request.params.path;\r\n    }\r\n\r\n    return './public' + request.params.path;\r\n};\r\n\r\nhttp.addRoute({ method: 'GET', path: '/{path}', handler: { file: filePath } });\r\n\r\nhttp.start();\r\n```\r\n\r\n\r\n#### Directory\r\n\r\nDirectory handlers provide a flexible way to serve static content from an entire directory tree. Similar to other web servers, **hapi**\r\nallows mapping between a request path component to resources within a file system directory, including serving a default index.html or\r\na directory content listing.\r\n\r\nRoutes utilizing the directory handler must include a single path parameter at the end of the path string (e.g. _'/path/to/somewhere/{param}'_).\r\nThe directory handler is an object with the following options:\r\n- `path` - a required path string or function. If the `path` is a string, it is used as the prefix for any resources requested within the route by appending the required route path parameter to the provided string. Alternatively, the `path` can be a function with the signature _'function (request) { return './path'; }'_.  The function is passed the request object and must return a string with the relative or absolute path to the static resource. Relative paths are resolved based on the server's `files` option as described in (Files)[#files].\r\n- `index` - optional boolean, determines if 'index.html' will be served if exists in the folder when requesting a directory. Defaults to _'true'_.\r\n- `listing` - optional boolean, determines if directory listing is generated when a directory is requested without an index document. Defaults to _'false'_.\r\n- `showHidden` - optional boolean, determines if hidden files will be shown and served.  Defaults to _'false'_.\r\n\r\nThe required route path parameter can use any of the parameter options (e.g. '{param}', '{param?}', '{param*}'). For example, to server\r\nonly files in the top level folder and not to any subfolder use _'{path?}'_. If it is safe to navigate to child folders and files then\r\nuse _'{path*}'_. Similarly, if the server should only allow access to a certain level of subfolders then use _'{path*2}'_.\r\n\r\nThe following example shows how to serve a directory named _'public'_ and enable a directory listing in case a 'index.html' file doesn't exist:\r\n\r\n```javascript\r\n// Create Hapi server\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\n// Serve the public folder with listing enabled\r\nhttp.addRoute({ method: 'GET', path: '/{path*}', handler: { directory: { path: './public/', listing: true } } });\r\n\r\nhttp.start();\r\n```\r\n\r\nA function `path` can be used to serve different directory trees based on the incoming request. For example:\r\n\r\n```javascript\r\n// Create Hapi server\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\nvar directoryPath = function (request) {\r\n\r\n    if (isMobileDevice(request)) {\r\n        return './mobile';\r\n    }\r\n\r\n    return './public';\r\n};\r\n\r\nhttp.addRoute({ method: 'GET', path: '/{path*}', handler: { directory: { path: directoryPath } } });\r\n\r\nhttp.start();\r\n```\r\n\r\n\r\n#### View\r\n\r\nViews provide a better way of generating HTML than string and variable concatenation. Similar to other web servers, \r\n**hapi** views allow handlers to efficiently generate HTML using templates by executing an individual template with a\r\npre-generated context object (which may contain dynamic content).\r\n\r\nThe following example shows how to render a basic handlebars/mustache template:\r\n\r\n**index.js**\r\n```javascript\r\n    \r\n    var http = new Hapi.Server('0.0.0.0', 8080, {\r\n        views: {\r\n            path: __dirname + '/templates'\r\n        }\r\n    });\r\n        \r\n    var handler = function (request) {\r\n\r\n        request.reply.view('index', {\r\n            title: 'Views Example',\r\n            message: 'Hello, World'\r\n        }).send();\r\n    };\r\n\r\n    http.addRoute({ method: 'GET', path: '/', handler: handler });\r\n    http.start();\r\n```\r\n\r\nAn example template:\r\n\r\n**templates/index.html**\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>{{title}}</title>\r\n    </head>\r\n    <body>\r\n        <div>\r\n            <h1>{{message}}</h1>\r\n        </div>\r\n    </body>\r\n</html>\r\n```\r\n\r\nOn request, the user would be shown:\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>Views Example</title>\r\n    </head>\r\n    <body>\r\n        <div>\r\n            <h1>Hello, World</h1>\r\n        </div>\r\n    </body>\r\n</html>\r\n```\r\n\r\n\r\nThe Hapi.Server settings may also be overridden on a per view basis without affecting others:\r\n\r\n    request.render.view(tmpl, ctx, { path: '/a/different/path' });\r\n\r\nFull working examples covering features such as layouts and partials can be found in the `examples/views/handlebars` folder.\r\n\r\n#### Views Handler\r\n\r\nThe route handler can be set to an object that points to a view file in order to make it easy to render a simple view.  The view context will have the payload, params, or querystring data that are available with the request.  For example, to render an _'about'_ page a route can be added as follows:\r\n\r\n```javascript\r\n    var http = new Hapi.Server('0.0.0.0', 8080, {\r\n        views: {\r\n            path: __dirname + '/templates'\r\n        }\r\n    });\r\n\r\n    http.addRoute({ method: 'GET', path: '/{user}/about', handler: { view: 'about });\r\n    http.start();\r\n```\r\n\r\nThen in the view there are properties for params, payload, and querystring.  Below is an example of rendering the _'user'_ that is passed in from the request path along with related values from the querystring.\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>About {{ params.user }}</title>\r\n    </head>\r\n    <body>\r\n        <div>\r\n            <h1>About {{ params.user }}</h1>\r\n            <div>\r\n                Age: {{ querystring.age }}\r\n            </div>\r\n            <div>\r\n                Interests: {{ querystring.interests }}\r\n            </div>\r\n        </div>\r\n    </body>\r\n</html>\r\n```\r\n\r\n#### Layouts\r\n\r\nThe View system supports Layouts. Layouts are a single template file which is used as a parent template for individual view templates - the view template is directly embedded in a layout. This allows developers to give the website(s) a consistent appearance while also keeping HTML code as well as minimizing repeated code (the boilerplate with stylesheet includes, javascript includes, html displayed on every page).\r\n\r\nTo use, set the Hapi view option `layout` to true and create a file `layout.html` in your `views.path`.\r\n\r\n**layout.js**\r\n```javascript\r\n\r\n    var options = {\r\n        views: {\r\n            path: __dirname + '/templates',\r\n            engine: {\r\n                module: 'handlebars',\r\n                extension: 'html'\r\n            },\r\n            layout: true\r\n        }\r\n    };\r\n    \r\n    var handler = function (request) {\r\n\r\n        request.reply.view('withLayout/index', {\r\n            title: 'examples/views/layout.js | Hapi ' + Hapi.utils.version(),\r\n            message: 'Hello World!\\n'\r\n        }).send();\r\n    };\r\n\r\n    var server = new Hapi.Server(8080, options);\r\n    server.addRoute({ method: 'GET', path: '/', handler: handler });\r\n    server.start();\r\n```\r\n\r\n**templates/layout.html**\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>{{title}}</title>\r\n    </head>\r\n    <body>\r\n        <p>Layout header</p>\r\n        {{{ content }}}\r\n        <p>Layout footer</p>\r\n    </body>\r\n</html>\r\n```\r\n\r\n**templates/withLayout/index.html**\r\n```html\r\n<div>\r\n    <h1>{{message}}</h1>\r\n</div>\r\n```\r\n\r\n**returned to user**:\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>examples/views/layout.js | Hapi 0.11.1</title>\r\n    </head>\r\n    <body>\r\n        <p>Layout header</p>\r\n        <div>\r\n            <h1>Hello World!\\n</h1>\r\n        </div>\r\n        <p>Layout footer</p>\r\n    </body>\r\n</html>\r\n```\r\n\r\nThe `layout.html` must be located in the path or an error will be returned. Notice that the content from view template `withLayout/index` is executed with the context provided in the handler then embedded into the layout in place of `{{{ content }}}`. To change the keyword for embedding the view template, set the `layoutKeyword` option.\r\n\r\n\r\n#### Partials\r\n\r\nThe View system also supports Partials. Partials are small segments of template code that can be nested and reused throughout other templates.\r\n\r\n**partials.js**\r\n```javascript\r\n\r\n    var options = {\r\n        views: {\r\n            path: __dirname + '/templates',\r\n            engine: {\r\n                module: 'handlebars'\r\n            },\r\n            partials: {\r\n                path: __dirname + '/templates/withPartials'\r\n            }\r\n        }\r\n    };\r\n    \r\n    var handler = function (request) {\r\n\r\n        request.reply.view('withPartials/index', {\r\n            title: 'examples/views/partials.js | Hapi ' + Hapi.utils.version(),\r\n            message: 'Hello World!\\n'\r\n        }).send();\r\n    };\r\n\r\n    var server = new Hapi.Server(3000, options);\r\n    server.addRoute({ method: 'GET', path: '/', handler: handler });\r\n    server.start();\r\n```\r\n\r\n**withPartials/index.html**\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>{{title}}</title>\r\n    </head>\r\n    <body>\r\n        {{> header}}\r\n        <div>\r\n            <h1>{{message}}</h1>\r\n        </div>\r\n        {{> footer}}\r\n    </body>\r\n</html>\r\n```\r\n\r\n**withPartials/header.html**\r\n```html\r\n<div>\r\n    <h3>Views with Partials</h3>\r\n</div>\r\n```\r\n\r\n**withPartials/footer.html**\r\n```html\r\n<footer>\r\n    <p>hapi.js 2013</p>\r\n</footer>\r\n```\r\n\r\n**returned to user**\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n    <head>\r\n        <title>examples/views/partials.js | Hapi 0.11.1</title>\r\n    </head>\r\n    <body>\r\n        <div>\r\n            <h3>Views with Partials</h3>\r\n        </div>\r\n        <div>\r\n            <h1>Hello World!\\n</h1>\r\n        </div>\r\n        <footer>\r\n            <p>hapi.js 2013</p>\r\n        </footer>\r\n    </body>\r\n</html>\r\n```\r\n\r\nThe above example will use `views.partials.path` as the partials directory. Hapi will recursively find template files and automatically add them to the partial registry for use in view templates. \r\n\r\nDeeply nested partials are also supported.  A view template can reference a partial stored in `viewsPath/nav/nav.html` like so:\r\n\r\n```html\r\n    <body>\r\n        {{> nav/nav}}\r\n        <div id=\"container\">\r\n    ...\r\n```\r\n\r\n\r\n\r\n### Documentation\r\n\r\n**This is an experimental feature and is likely to change!**\r\n\r\nIn order to make it easy to generate documentation for the routes you add to **hapi**, a documentation generator is provided. By default the documentation\r\ngenerator is turned _off_. To enable the docs endpoint add a new route with a handler object that has a docs property set to true or to an object with the following options:\r\n- `indexTemplatePath` - the file path where the index template file is located.  Default is 'lib/templates/index.html' inside the lout module.\r\n- `indexTemplate` - the raw source of a index template to use.  If `indexTemplate` is provided then it will be used over the file located at `indexTemplatePath`.\r\n- `routeTemplatePath` - the file path where the routes template file is located.  Default is 'lib/templates/route.html' inside the lout module.\r\n- `routeTemplate` - the raw source of a route template to use.  If `routeTemplate` is provided then it will be used over the file located at `routeTemplatePath`.\r\n- `templateParams` - an optional object of any extra information you want to pass into your template, this will be located in the templateParams object in the template data object.\r\n\r\nBy default there is an index page that lists all of the available routes configured in **hapi** that is located at the `docsEndpoint`.  From this page users are able to navigate to individual routes to read the related documentation.\r\n\r\nThe simplest example of enabling docs on a site is shown in the following example:\r\n\r\n```javascript\r\n// Create Hapi server\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\nhttp.addRoute({ method: 'GET', path: '/docs', handler: { docs: true } });\r\n\r\nhttp.start();\r\n```\r\n\r\n\r\n#### Request Logging\r\n\r\nIn addition to the [General Events Logging](#general-events-logging) mechanism provided to log non-request-specific events, **hapi** provides\r\na logging interface for individual requests. By associating log events with the request responsible for them, it is easier to debug and understand\r\nthe server's behavior. It also enables batching all the request log events and deliver them to the monitor as a single package.\r\n\r\nThe request object is also decorated with the following methods.\r\n- _'log(tags, [data, timestamp])'_ which adds a record to the request log where:\r\n    - _'tags'_ - a single string or an array of strings (e.g. _['error', 'database', 'read']_) used to identify the logged event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events.\r\n    - _'data'_ - an optional message string or object with the application data being logged.\r\n    - _'timestamp'_ - an optional timestamp override (if not present, the server will use current time), expressed in milliseconds since 1970 (_new Date().getTime()_).\r\n- _'getLog(tags)'_ - Returns an array of events which match the tag(s) specifed.\r\n\r\nFor example:\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\n// Create Hapi servers\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\n// Route handler\r\nvar testLogs = function (request) {\r\n\r\n    request.log('error', new Error('Something failed'));\r\n    \r\n    if (request.getLog('error').length === 0) {\r\n        request.reply('Success!');\r\n    }\r\n    else {\r\n        request.reply('Failure!');\r\n    }\r\n};\r\n\r\n// Set routes\r\nhttp.addRoute({ method: 'GET', path: '/', handler: testLogs });\r\n\r\n// Start Hapi servers\r\nhttp.start();\r\n```\r\n\r\nThe 'request.log' method is always available.\r\n\r\n\r\n### Query Validation\r\n\r\nWhen a request URI includes a query component (the key-value part of the URI between _?_ and _#_), the query is parsed into its individual\r\nkey-value pairs (see [Query String](http://nodejs.org/api/querystring.html#querystring_querystring_parse_str_sep_eq_options)) and stored in\r\n'request.query'.\r\n\r\nThe route `config.validate.query` defines the query validation rules performed before the route handler is invoked. Supported values:\r\n- _'true'_ or _'{}'_ - any query parameters allowed (no validation performed).  This is the default.\r\n- _'false'_ - no query parameters allowed.\r\n- a validation rules object as described in [Data Validation](#data-validation).\r\n\r\n\r\n### Payload Validation\r\n\r\nThe route `config.validate.schema` defines the payload validation rules performed before the route handler is invoked. Supported values:\r\n- _'true'_ or _'{}'_ - any payload allowed (no validation performed). This is the default.\r\n- _'false'_ - no payload allowed.\r\n- a validation rules object as described in [Data Validation](#data-validation).\r\n\r\n\r\n### Path Validation\r\n\r\nWhen a request comes in for a route that allows for path parameters the request is path parameters are parsed into request.params.\r\n\r\nThe route `config.validate.path` defines the path validation rules performed before the route handler is invoked. Supported values:\r\n- _'true'_ or _'{}'_ - any path parameters allowed (no validation performed).  This is the default.\r\n- _'false'_ - no path variables allowed.\r\n- a validation rules object as described in [Data Validation](#data-validation).\r\n\r\n\r\n### Response Validation\r\n\r\nThe route `config.response` defines the payload validation rules performed after the route handler is invoked. Supported values:\r\n- _'null'_ - any payload allowed (no validation performed). This is the default.\r\n- _'false'_ or _'{}'_ - no payload allowed.\r\n- an object with the following options\r\n    - _'schema'_ - a validation rules object as described in [Data Validation](#data-validation).\r\n    - _'sample'_ - the percentage of responses to validate.  By default 100% of responses will be validated, to turn this off set the value to 0.  To validate half of the responses set this value to 50.\r\n    - _'failAction'_ - _'error'_ (return 500), _'log'_ (report error but send reply as-is), or _'ignore'_ (send reply as-is) when a response is invalid. Defaults to _'error'_.\r\n\r\nResponse validation can only be performed on object responses and will otherwise result in an error.\r\n\r\n\r\n### Caching\r\n\r\n'GET' routes may be configured to use the built-in cache if enabled using the server `cache` option. The route cache config has the following options:\r\n- `mode` - determines if the route is cached on the server, client, or both. Defaults to _'server+client'_.\r\n    - `server+client` - Caches the route response on the server and client (default)\r\n    - `client` - Sends the Cache-Control HTTP header on the response to support client caching\r\n    - `server` - Caches the route on the server only\r\n    - `none` - Disable cache for the route on both the client and server\r\n- `segment` - Optional segment name, used to isolate cached items within the cache partition. Defaults to '#name' for server helpers and the path fingerprint (the route path with parameters represented by a '?' character) for routes. Note that when using the MongoDB cache strategy, some paths will require manual override as their name will conflict with MongoDB collection naming rules.\r\n- `expiresIn` - relative expiration expressed in the number of milliseconds since the item was saved in the cache. Cannot be used together with `expiresAt`.\r\n- `expiresAt` - time of day expressed in 24h notation using the 'MM:HH' format, at which point all cache records for the route expire. Cannot be used together with `expiresIn`.\r\n- `strict` - determines if only _'Cacheable'_ responses are allowed.  If a response that is not _'Cacheable'_ is returned and strict mode is enabled then an error will be thrown.  Defaults to '_false_'.\r\n\r\nFor example, to configure a route to be cached on the client and to expire after 2 minutes the configuration would look like the following:\r\n```\r\n{\r\n    mode: 'client',\r\n    expiresIn: 120000\r\n}\r\n```\r\n\r\nThe server-side cache also supports these advanced options:\r\n- `staleIn` - number of milliseconds from the time the item was saved in the cache after which it is considered stale. Value must be less than 86400000 milliseconds (one day) if using `expiresAt` or less than the value of `expiresIn`. Used together with `staleTimeout`.\r\n- `staleTimeout` - if a cached response is stale (but not expired), the route will call the handler to generate a new response and will wait this number of milliseconds before giving up and using the stale response. When the handler finally completes, the cache is updated with the more recent update. Value must be less than `expiresIn` if used (after adjustment for units).\r\n\r\n\r\n### Prequisites\r\n\r\nBefore the handler is called, it is often necessary to perform other actions such as loading required reference data from a database. The `pre` option\r\nallows defining such pre-handler methods. The methods are called in order, unless a `mode` is specified with value 'parallel' in which case, all the parallel methods\r\nare executed first, then the rest in order. The `pre` is a mixed array of functions and objects. If a function is included, it is the same as including an\r\nobject with a single `method` key. The object options are:\r\n- `method` - the function to call. The function signature is _'function (request, next)'_. _'next([result])'_ must be called when the operation concludes. If the result is an Error, execution of other prerequisites stops and the error is handled in the same way as when an error is returned from the route handler.\r\n- `assign` - key name to assign the result of the function to within 'request.pre'.\r\n- `mode` - set the calling order of the function to 'serial' or 'parallel'. Defaults to 'serial'.\r\n\r\nFor example:\r\n```javascript\r\n// Create Hapi servers\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\nvar fetch1 = function (request, next) {\r\n\r\n    next('Hello');\r\n};\r\n\r\nvar fetch2 = function (request, next) {\r\n\r\n    next('World');\r\n};\r\n\r\nvar fetch3 = function (request, next) {\r\n\r\n    next(request.pre.m1 + ' ' + request.pre.m2);\r\n};\r\n\r\nvar get = function (request) {\r\n\r\n    request.reply(request.pre.m3 + '\\n');\r\n};\r\n\r\n// Set routes\r\nhttp.addRoute({\r\n    method: 'GET',\r\n    path: '/',\r\n    config: {\r\n        pre: [\r\n            { method: fetch1, assign: 'm1', mode: 'parallel' },\r\n            { method: fetch2, assign: 'm2', mode: 'parallel' },\r\n            { method: fetch3, assign: 'm3' },\r\n        ],\r\n        handler: get\r\n    }\r\n});\r\n\r\n// Start Hapi servers\r\nhttp.start();\r\n```\r\n\r\n\r\n## Data Validation\r\n\r\n**hapi** supports a rich set of data types and validation rules which are described in detail in the [**joi** module documentation](/walmartlabs/joi).\r\nFor example:\r\n\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\nvar S = Hapi.Types.String;\r\nvar I = Hapi.Types.Int;\r\n\r\nvar rules = {\r\n    username: S().required().alphanum().min(3).max(30).with('email'),\r\n    password: S().regex(/[a-zA-Z0-9]{3,30}/).without('token'),\r\n    token: S(),\r\n    birthyear: I().min(1850).max(2012),\r\n    email: S().email(),\r\n    type: S().valid('admin', 'limited', 'normal')\r\n};\r\n```\r\n\r\nIn which:\r\n- 'username' is a required alphanumeric string, 3 to 30 characters long, and must appear together with 'email'.\r\n- 'password' is an optional string matching a regular expression, and must not appear together with 'token'.\r\n- 'token' is an optional string.\r\n- 'birthyear' is an optional integer between 1980 and 2012.\r\n- 'email' is an optional string with valid email address.\r\n- 'type' is an optional string which must be set to one of three available values.\r\n\r\n\r\n## Response Errors\r\n\r\nThe 'Hapi.Error' module provides helper methods to generate error responses:\r\n- _'badRequest([message])'_ - HTTP 400 (Bad Request).\r\n- _'unauthorized([message])'_ - HTTP 401 (Unauthorized).\r\n- _'forbidden([message])'_ - HTTP 403 (Not Allowed).\r\n- _'notFound([message])'_ - HTTP 404 (Not Found).\r\n- _'internal([message, data])'_ - HTTP 500 (Internal Error). The optional _message_ and _data_ values are not returned to the client but are logged internally.\r\n\r\nThe _message_ value is optional and will be returned to the client in the response unless noted otherwise. For example:\r\n\r\n```javascript\r\nfunction onUnknownRoute(request) {\r\n\r\n    request.reply(Hapi.Error.unknown('Sorry, nobody home'));\r\n}\r\n```\r\n\r\nError responses are send as JSON payload with the following keys (unless an [error response override](#errors) is configured):\r\n- _code_ - the HTTP status code (e.g. 400).\r\n- _error_ - the HTTP status message (e.g. 'Bad Request').\r\n- _message_ - the returned message if provided.\r\n\r\nThe complete error repsonse including any additional data is added to the request log.\r\n\r\n\r\n## State Management\r\n\r\n### Raw Cookies\r\n\r\nCookies can be set directly via the response _'state(name, value, options)'_ interface where:\r\n- 'name' - is the cookie name,\r\n- 'value' - is the cookie value, and\r\n- 'options' - is an optional structure with the following optional keys:\r\n    - `ttl' - time-to-live in milliseconds.\r\n    - `isSecure` - sets the 'Secure' flag.\r\n    - `isHttpOnly` - sets the 'HttpOnly' flag.\r\n    - `path` - the path scope.\r\n    - `domain` - the domain scope.\r\n    - `encoding` - encoding performs on the provided value before serialization. Options are:\r\n        - 'none' - no encoding. This is the default value. Value must be a string.\r\n        - 'base64' - string value is encoded using Base64.\r\n        - 'base64json' - object value is JSON-stringified than encoded using Base64.\r\n        - 'form' - object value is encoded using the _x-www-form-urlencoded_ method.\r\n\r\nCookie definitions can be registered with the server using the server's _'addState(name, options)'_ method, where 'options' is the same as above.\r\nIf a cookie definition is found, the options are used for that cookie as defaults before other options specified at the time of state() invocation\r\nare applied. In addition, the `encoding` option is used when receiving a cookie from the client to parse the cookie's value.\r\n\r\n\r\n## General Events Logging\r\n\r\nMost of the server's events usually relate to a specific incoming request. However, there are sometimes event that do not have a specific request\r\ncontext. **hapi** provides a logging mechanism for general events using a singleton logger 'Hapi.Log' module. The logger provides the following methods:\r\n- _'event(tags, [data, timestamp])'_ - generates an event where:\r\n    - _'tags'_ - a single string or an array of strings (e.g. _['error', 'database', 'read']_) used to identify the event. Tags are used instead of log levels and provide a much more expressive mechanism for describing and filtering events.\r\n    - _'data'_ - an optional message string or object with the application data being logged.\r\n    - _'timestamp'_ - an optional timestamp override (if not present, the server will use current time), expressed in milliseconds since 1970 (_new Date().getTime()_).\r\n- _'print(event)'_ - outputs the given _'event'_ to the console.\r\n\r\nThe logger is an event emitter. When an event is generated, the logger's _'log'_ event is emitted with the event object as value.\r\nIf no listeners are registered, the event is printed to the console.\r\n\r\nFor example:\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\n// Listen to log events\r\nHapi.Log.on('log', function (event) {\r\n\r\n    // Send to console\r\n    Hapi.Log.print(event);\r\n});\r\n\r\n// Generate event\r\nHapi.Log.event(['test','info'], 'Test event');\r\n\r\n```\r\n\r\n\r\n## Request Tails\r\n\r\nIt is often desirable to return a response as quickly as possible and perform additional (slower) actions afterwards (or in parallel). These\r\nactions are called request tails. For example, a request may trigger a database update tail that should not delay letting the client know the\r\nrequest has been received and will be processed shortly. However, it is still desirable to associate the tails with the request and to know\r\nwhen every single request related action has completed (in other words, when the request stopped wagging).\r\n\r\n**hapi** provides a simple facility for keeping track of pending tails by providing the following request methods:\r\n- _'addTail([name])'_ - registers a named tail and returns a tail function. The tail function must be retained and used to remove the tail when completed. The method is available on every event or extension hook prior to the 'tail' event.\r\n- _'removeTail(tail)'_ - removes a tail to notify the server that the associated action has been completed.\r\n\r\nAlternatively, the returned tail function can be called directly without using the _removeTail()_ method.\r\n\r\nFor example:\r\n```javascript\r\nvar Hapi = require('hapi');\r\n\r\n// Create Hapi servers\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\n// Route handler\r\nvar get = function (request) {\r\n\r\n    var tail1 = request.addTail('tail1');\r\n    setTimeout(function () {\r\n\r\n        request.removeTail(tail1);              // Using removeTail() interface\r\n    }, 5000);\r\n\r\n    var tail2 = request.addTail('tail2');\r\n    setTimeout(function () {\r\n\r\n        tail2();                                // Using tail function interface\r\n    }, 2000);\r\n\r\n    request.reply('Success!');\r\n};\r\n\r\n// Set routes\r\nhttp.addRoute({ method: 'GET', path: '/', handler: get });\r\n\r\n// Listen to tail events\r\nhttp.on('tail', function (request) {\r\n\r\n    console.log('Wag the dog');\r\n});\r\n\r\n// Start Hapi servers\r\nhttp.start();\r\n```\r\n\r\n\r\n## Request Injection\r\n\r\nRequest injection is the process of simulating an HTTP request without making an actual socket request. Injection is useful for testing\r\nor debugging purposes, but also for invoking routing logic internally without the overhead or limitations of the network stack. For example,\r\nimplementing a batch mechanism which calls multiple internal routes.\r\n\r\n**hapi** uses the [**shot**](https://github.com/hueniverse/shot) module for performing injections. To inject a request, use the server's\r\n_'inject(options, callback)'_ method in which:\r\n- _'options'_ - is an object containing the request information. Available options:\r\n    - `method` - the request HTTP method. Required.\r\n    - `url` - the request URL (as it would appear in an incoming node request object). Required.\r\n    - `headers` - any request headers. Optional.\r\n    - `payload` - a string or Buffer containing the request payload. Optional.\r\n    - `session` - a session object containing authentication information as described in [Route Handler](#route-handler). The `session` option is used to bypass the default authentication validation and use a pre-authenticated session. Optional.\r\n- _'callback'_ - a callback function with the signature _'function (res)'_ where 'res' is the injection response object. The response object properties include:\r\n    - _'headers'_ - an array containing the headers set.\r\n    - _'statusCode'_ - the HTTP status code.\r\n    - _'readPayload()'_ - the payload converted to a string.\r\n    - _'result'_ - if present, the original route handler reply object.\r\n    - _'raw'_ - the injection request and response objects.\r\n\r\n**This is an experimental feature and is likely to change!**\r\n\r\nFor example:\r\n\r\n```javascript\r\n// Create Hapi server\r\nvar http = new Hapi.Server('0.0.0.0', 8080);\r\n\r\n// Handler\r\nvar get = function (request) {\r\n\r\n    request.reply('Success!');\r\n};\r\n\r\n// Set routes\r\nhttp.addRoute({ method: 'GET', path: '/', handler: get });\r\n\r\n// Injection options\r\nvar req = {\r\n    method: 'get',\r\n    url: '/'\r\n};\r\n\r\nhttp.inject(req, function (res) {\r\n\r\n    console.log(res.result || res.readPayload());\r\n});\r\n```\r\n\r\n\r\n## Server Helpers\r\n\r\nServer helpers are functions registered with the server and can be used throughout the application. The advantage of using helpers is\r\nthat they can be configured to use the built-in cache and shared across multiple request handlers. This provides a useful method for\r\nspeeding up performance by declaring functions as common utilities with a shared cache.\r\n\r\nThe signature of helper functions is _'function (arg1, arg2, ..., arg3, next)'_ where next is a function defined as _'function (result)'_.\r\n'result' can be any value or an Error (which must be generated using the **hapi** Error module is the helper is used as a prerequisite method).\r\n\r\nTo add a helper, use the server's _'addHelper(name, method, options)'_ method where:\r\n- _'name'_ - is a unique helper name used to call the method (e.g. 'server.helpers.name').\r\n- _'method'_ - is the helper function.\r\n- _'options'_ - optional settings where:\r\n    - `cache` - cache configuration as described in [Caching](#caching). `mode` can use the default or be set to 'server'.\r\n    - `keyGenerator` - the server will automatically generate a unique key if the function's arguments (with the exception of the last 'next' argument) are all of type string, number, or boolean. However if the function uses other types of arguments, a key generation function must be provided which takes the same arguments as the function and returns a unique string (or null if no key can be generated). Note that when the keyGenerator method is invoked, the arguments list will include the next argument which must not be used in calculation of the key.\r\n\r\nFor example:\r\n```javascript\r\n// Create Hapi server\r\nvar server = new Hapi.Server('0.0.0.0', 8080);\r\n\r\nvar user = function (id, next) {\r\n\r\n    next({ id: id });\r\n};\r\n\r\nvar options = {\r\n    cache: {\r\n        expiresIn: 2000,\r\n        staleIn: 1000,\r\n        staleTimeout: 100\r\n    },\r\n    keyGenerator: function (id) {\r\n\r\n        return id;\r\n    };\r\n};\r\n\r\nserver.addHelper('user', user, options);\r\n\r\nserver.helpers.user(4, function (result) {\r\n\r\n    console.log(result);\r\n});\r\n```\r\n\r\nOr used as a prerequisites:\r\n```javascript\r\nhttp.addRoute({\r\n    method: 'GET',\r\n    path: '/user/{id}',\r\n    config: {\r\n        pre: [\r\n            {\r\n                assign: 'user',\r\n                method: function (request, next) {\r\n\r\n                    request.server.helpers.user(request.params.id, next);\r\n                }\r\n            }\r\n        ],\r\n        handler: function (request) {\r\n\r\n            request.reply(request.pre.user);\r\n        }\r\n    }\r\n});\r\n```\r\n\r\n\r\n# The End\r\n\r\nhapi hapi, joi joi\r\n",
  "readmeFilename": "README.md",
  "_id": "hapi@0.11.3",
  "_from": "hapi@0.11.x"
}
